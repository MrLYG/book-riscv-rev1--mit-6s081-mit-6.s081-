# 2.1 Abstracting physical resources

当遇到一个操作系统时，人们可能会问的第一个问题是为什么要有这个系统？也就是说，我们可以把图1.2中的系统调用作为一个库来实现，应用程序与之链接。在这个想法中，每个应用程序甚至可以有自己的库来满足其需求。应用程序可以直接与硬件资源交互，并以最适合应用程序的方式使用这些资源（例如，实现高性能）。一些用于嵌入式设备或实时系统的操作系统就是以这种方式组织的。

这种库方式的缺点就是，如果有多个应用运行，这些应用必须正确运行，例如，每个程序必须周期性的放弃CPU让其他的程序可以运行。如果所有的应用互相信任并且没有bug，这种合作性的分时方案是可以的。但是，更典型的情况是应用之间不相互信任，且有bug，所以人们经常希望有比合作性的方案更强的隔离性。

为了实现强隔离性，禁止应用程序直接访问敏感的硬件资源并将资源抽象成服务时很有帮助的。例如，Unix应用于存储交互只通过文件系统的opne，read，wirte和close系统调用，而不是直接读写磁盘。这为应用程序带来了路径名的便利，而且它允许操作系统（作为接口的实现者）管理磁盘。即使不关心隔离问题，那些有意交互的程序（或者只是希望互不干扰）可能发现文件系统是比直接使用磁盘更便利的抽象。

同样的，Unix在进程间透明地选择CPU硬件，必要时保存和回复寄存器状态，因此应用不用注意到时间共享。这种透明允许操作系统去共享CPU，甚至当一些应用处于无限循环中。

另一个例子，Unix使用exec去构建他们的内存镜像，而不是直接于物理内存交互。这允许操作系统决定将一个进程放在内存的哪个位置；如果内存紧张，操作系统或许甚至将进程的一部分数据存入磁盘中。Exec也给用户提供了便利的文件系统去存储可执行的程序镜像。

在Unix进程间的很多交互形式通过文件描述符实现。文件描述符不仅可以抽象远离很多细节（例如，管道或文件中的数据存储在哪里），也可以定义一种简单的交互方式。例如，如果在管道的一个程序失败，内核会生成一个文件结束信号给管道中的下一个进程。

图1.2中的系统调用接口是经过精心设计的，既为程序员提供了方便，又有可能实现强隔离。Unix接口并不是抽象资源的唯一方法，但它已被证明是一个非常好的方法。