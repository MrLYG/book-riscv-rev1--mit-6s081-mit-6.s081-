# Chapter 4 Traps and system calls

有三种事件会导致CPU搁置普通指令的执行，强行将控制权转换到处理该事件的特殊代码。一种情况是系统调用，当一个用户执行要求内核为它做一些事情的时候。另一种情况是异常:用户或者内核的一条指令做了非法的事情，例如除以0或者使用一个无效的虚拟地址。第三种情况是设备中断，当设备发出需要注意的信号时，例如当磁盘硬件完成读或者写的请求。

本书使用trap这些指令的通俗术语。一般，代码执行是发送trap，在之后都会被恢复，并不需要注意任何会发生的特殊事情。也就是说，我们常希望trap过程是透明的；这一点对于中断是特别重要的，被中断的代码通常是不知道自己陷入了trap。通常的顺序是:trap强迫控制权转换到内核；内核保存好寄存器和一些其他的状态，以便恢复执行；内核执行合适的处理代码(例如一个系统调用实现或者设备驱动);内核恢复保存的状态并从trap返回；然后原始的代码从原来陷入trap的地方恢复。

xv6内核处理所有的trap。这是系统调用的特性。这对中断也是有意义的，因为隔离性要求用户进程不能直接使用设备，并因为只有内核拥有设备处理所需的状态。这对异常也很有意义，因为xv6响应所有来自用户空间的异常，并杀死该违规程序。

Xv6 trap 处理分为四个阶段：RISC-V CPU采取的硬件动作，为内核C代码准备的汇编入口，处理trap的C 处理程序，以及系统调用或设备驱动服务。虽然三种trap类型之间的共性表明，内核可以用单一的代码入口处理所有的trap，但事实证明，为三种不同的情况，即来自用户空间的trap、来自内核空间的trap和定时器中断，设置单独的汇编入口和C trap处理程序是很方便的。

[4.1 RISC-V trap machinery](4-1%20RISC-V%20trap%20machinery.md)